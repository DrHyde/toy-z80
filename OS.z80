ORG 0x0000
INCLUDE "_constants.z80"
INCLUDE "_macros.z80"

rst0:
        DI
        IM 1
        LD HL, 0x0000
        JR init__part2   ; jump to immediately after RST block

osfunc: ; RST 0x08
        PUSH AF                    ; first, see if we're already in OSFUNC
        LD A, (osfunc__in_osfunc)
        CP 0
        JR NZ, osfunc__chk_in_osfunc__NO
        JR osfunc__recurse        ; we are, so crash
osfunc__chk_in_osfunc__NO:
        INC A
        LD (osfunc__in_osfunc), A  ; we're not. record that we are
        ; PUSHDATA
    ;   ... do osfunc ...
        ; POPDATA
        DEC A                      ; mark that we're no longer in OSFUNC
        LD (osfunc__in_osfunc), A
        POP AF
        RET
osfunc__in_osfunc:
        DEFB 0x00
osfunc__recurse:                   ; ... print message ...
        JR osfunc__recurse

init__part2:
        LD SP, HL             ; initialise stack
;     ; slurp all ports to clear data
;         LD BC, 0x8000         ; B = num ports to slurp (each is a pair) / C = port to start at
; init__slurp_ports_loop:
;         LD HL, os_readport
;         PUSH HL
;         OSFUNC
;         POP HL                ; throw away what we put on the stack - OSFUNC will do this eventually
;         INC C                 ;
;         INC C                 ; point at next port
;         DJNZ init__slurp_ports_loop
;
     ; start the clock
        LD A, 1
        OUT (port_hw_start_clock), A

        EI

load_shell:
        ; LD HL, shell_name
        ; PUSH HL
        ; LD HL, os_exec
        ; PUSH HL
        ; OSFUNC
        JR load_shell
shell_name:
        DEFM "shell.cmd", 0x00
os_readport:
os_exec:

ORG 0x0062

clock_low16:
        DEFW 0
clock_high16:
        DEFW 0

nmi:
        PUSH AF
        LD A, (nmi__in_nmi)
        CP 0
        JR Z, nmi__chk_in_nmi__NO
        POP AF
        RETN
nmi__chk_in_nmi__NO:
        INC A                     ; we're not. record that we are
        LD (nmi__in_nmi), A

    ; inc clock
        PUSH HL
        LD HL, (clock_low16)      ; first the low 16 bits
        INC L
        JR NZ, nmi__clock_store_low16
        INC H
nmi__clock_store_low16:
        LD (clock_low16), HL
        JR NZ, nmi__finished_updating_clock ; no need to bump high 16  if the INC H didn't result in zero

        LD HL, (clock_high16)     ; update the high sixteen bits
        INC L
        JR NZ, nmi__clock_store_high16
        INC H
nmi__clock_store_high16:
        LD (clock_high16), HL
nmi__finished_updating_clock:
        POP HL

        ;   ... process switch? ...

        DEC A                     ; record that we're no longer processing an NMI
        LD (nmi__in_nmi), A
        POP AF
        RETN

nmi__in_nmi:
        DEFB 0x00
