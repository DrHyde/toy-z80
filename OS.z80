ORG 0x0000
INCLUDE "_constants.z80"
INCLUDE "_macros.z80"

rst0:
        DI
        IM 1
        LD HL, stack_top + 1
        JR init__part2   ; jump to immediately after RST block

osfunc: ; RST 0x08
        SWAPREGS                  ; first, see if we're already in OSFUNC
osfunc__in_osfunc equ $ + 1
        LD A, 0                   ; this 0 is correct for the first call and will
                                  ; be modified by future calls and on exit
        CP 1
        JR Z, osfunc__recurse     ; we are, so crash
        INC A                     ; we're not. record that we are
        LD (osfunc__in_osfunc), A
    ;   ... do osfunc ...
        LD A, (osfunc__in_osfunc)
        DEC A                      ; mark that we're no longer in OSFUNC
        LD (osfunc__in_osfunc), A
        SWAPREGS
        RET
osfunc__recurse:                   ; ... print message ...
        JR osfunc__recurse

init__part2:
        LD SP, HL             ; initialise stack
;     ; slurp all ports to clear data
;         LD BC, 0x8000         ; B = num ports to slurp (each is a pair) / C = port to start at
; init__slurp_ports_loop:
;         LD HL, os_readport
;         PUSH HL
;         OSFUNC
;         POP HL                ; throw away what we put on the stack - OSFUNC will do this eventually
;         INC C                 ;
;         INC C                 ; point at next port
;         DJNZ init__slurp_ports_loop
;
     ; start the clock
        LD A, 1
        OUT (port_hw_start_clock), A
        EI

load_shell:
        ; LD HL, shell_name
        ; PUSH HL
        ; LD HL, os_exec
        ; PUSH HL
        ; OSFUNC
        JR load_shell

        ; add B little-endian bytes from (HL) to (DE), destroys B, AF/DE/HL
add_int:
        OR A          ; reset C
add_loop:
        LD A,(DE)
        ADC A,(HL)    ; add (HL) and carry flag to A and set carry flag if necessary
        LD (DE),A
        INC HL
        INC DE
        DJNZ add_loop
        RET

        ; sub B little-endian bytes at (HL) from (DE), destroys B, AF/DE/HL
sub_int:
        OR A
sub_loop:
        LD A,(DE)
        SBC A,(HL)
        LD (DE),A
        INC HL
        INC DE
        DJNZ sub_loop
        RET

shell_name:
        DEFM "shell.cmd", 0x00
os_readport:
os_exec:

ORG 0x0062

clock_32_bits:
        DEFW 0
        DEFW 0

; can be called while in OS code or in user code, so must preserve
; registers and stack!
nmi:
        PUSH AF
        LD A, (nmi__in_nmi)
        CP 0
        JR Z, nmi__chk_in_nmi__NO
        POP AF
        RETN
nmi__chk_in_nmi__NO:
        INC A                     ; we're not. record that we are
        LD (nmi__in_nmi), A

        PUSH HL                   ; inc clock
        PUSH DE
        PUSH BC
        LD B, 4
        LD DE, clock_32_bits
        LD HL, _32_bit_little_endian_1
        CALL add_int
        POP BC
        POP DE
        POP HL

        ;   ... process switch? ...

        LD A, 0                   ; record that we're no longer processing an NMI
        LD (nmi__in_nmi), A
        POP AF
        RETN
nmi__in_nmi:
        DEFB 0x00
_32_bit_little_endian_1:
        DEFW 1
        DEFW 0
