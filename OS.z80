ORG 0x0000
INCLUDE "_global_constants.z80"
INCLUDE "_macros.z80"

rst0:
        DI
        IM 1
        LD HL, 0x0000
        JR init__part2   ; jump to immediately after RST block

osfunc: ; RST 0x08
        PUSH AF                    ; first, see if we're already in OSFUNC
        LD A, (osfunc__in_osfunc)
        CP 0
        JR NZ, osfunc__chk_in_osfunc__NO
        JR osfunc__recurse        ; we are, so crash
osfunc__chk_in_osfunc__NO:
        INC A
        LD (osfunc__in_osfunc), A  ; we're not. record that we are
        ; PUSHDATA
    ;   ... do osfunc ...
        ; POPDATA
        DEC A                      ; mark that we're no longer in OSFUNC
        LD (osfunc__in_osfunc), A
        POP AF
        RET
osfunc__in_osfunc:
        DEFB 0x00
osfunc__recurse:                   ; ... print message ...
        JR osfunc__recurse

init__part2:
        LD SP, HL             ; initialise stack
;     ; slurp all ports to clear data
;         LD BC, 0x8000         ; B = num ports to slurp (each is a pair) / C = port to start at
; init__slurp_ports_loop:
;         LD HL, os_readport
;         PUSH HL
;         OSFUNC
;         POP HL                ; throw away what we put on the stack - OSFUNC will do this eventually
;         INC C                 ;
;         INC C                 ; point at next port
;         DJNZ init__slurp_ports_loop
;
     ; start the clock
        LD A, 1
        OUT (port_hw_start_clock), A

        EI

load_shell:
        ; LD HL, shell_name
        ; PUSH HL
        ; LD HL, os_exec
        ; PUSH HL
        ; OSFUNC
        JR load_shell
shell_name:
        DEFM "shell.cmd", 0x00
os_readport:
os_exec:
