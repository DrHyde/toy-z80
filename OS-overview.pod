=head1 OPERATING SYSTEM OVERVIEW

=head2 HARDWARE

There is 64K of memory and maximum of 256 ports.  Input ports are
arranged in pairs - the first of each pair, when read, will tell
how many bytes are available to be read.  The second is where
actual data is available.

=head3 PORTS

=head4 OUTPUT

=over

=item 0 - mem_bank

Write either 0, 1, 2 or 3 to indicate which chunk of memory to bank
(meaning the 16K chunk starting at N * 0x4000) following by a byte
indicating which ROM or which extra chunk of RAM to map in.

=item 1 - mem_unbank

Write either 0, 1, 2 or 3 to indicate which chunk of memory to unbank.

=item 2 - io_wr_stdout

Write a byte to the host machine's STDOUT.

=item 0xFF - hw_start_clock

Starts the machine clock.  The clock generates NMIs.  Writing anything
to this port works.

=back

=head4 INPUT

=head2 BOOT LOADER

The machine starts with PC = 0x0000, the Boot ROM paged in at 0x0000.
It will (eventually) allow choosing various OSes. For now however it
assumes that the OS ROM paged in at 0x4000.

The Boot loader first copies some code to the top of memory, then
jumps to it.  That code disables the Boot ROM, copies the first
256 bytes of the OS from the OS ROM to 0x0000, disables the
OS ROM, starts the clock, then jumps to 0x0000.

=head2 BOOTING THE OS

There's just a few bytes 0x0000, and a jump past the RST block.

The stack is initialised and the memory-map reset.

It then reads each port in turn until no more data are available,
flushing them.  The various bits of memory reserved for the OS are
then marked as such in the memory map.

The root fs is mounted.

/boot is executed.

Finally, file C</bin/shell.cmd> has memory allocated, is loaded, and is
executed.

=head1 MEMORY MAP

    0x0000 to 0x00FF: OS code
    0x0100 to 0x01FF: OS data
      0x0100 to 0x017F: process list (16 bytes per)
      0x0180 to 0x01FF: memory allocation table
                        each nibble (a PID) represents 512 bytes.
                        0b0000 means unallocated, 0b1111 means allocated
                        to the OS
    0xFF80 to 0xFFFF: OS stack
    ...
    0x0000 to 0xXXXX: OS code

=head1 ACCESS TO OS FUNCTIONS FROM USER CODE

To execute the function, C<RST 1>. RST 1 itself is not re-entrant. Input
parameters are pointed to by IX. IY contains the address of a big enough
chunk of memory for the output.

=head1 NMIs

The NMI increments a 32-bit clock counter in memory and may, if
we're not inside RST 1, perform a task switch.

=head2 RST 1

This function switches to the alternate register set, pages in the OS ROM
and runs the relevant function. When that function returns, the OS ROM is
paged back out and registers restored.

=head1 PROCESSES

User processes may be loaded and executed at any address.
Consequently they should not use any absolute addresses in their code.

Up to 14 concurrent processes are supported, numbered 1 to 14.

Associated with each process is a control structure.  This is stored
at 0xXXXX + 0xXX * PID and consists of:

    offset | size | use
    -------------------
    0      | 2    | storage for PC register
    1      | 2    | storage for SP register

